import psutil
import pygetwindow as gw
import win32process
import time
import win32gui
import re
from datetime import datetime

def active_win_open():
    """This function aims to get the PID of the active window and return the name of the program and its specific detail."""
    pattern_middle = r'([^\|\-—]+)\s*(?:\||-|—)\s*[^\-—]+$'
    pattern_program = r"(.+?)\s*(?:-|—)\s*(.+)"
    
    hwnd_activo = gw.getActiveWindow()
    if hwnd_activo is None:
        return None, None  # No active window
    
    hwnd_activo = hwnd_activo._hWnd
    active_pid = win32process.GetWindowThreadProcessId(hwnd_activo)[1]
    
    window_title = win32gui.GetWindowText(hwnd_activo)
    print(window_title)  # Debugging: Check what title is retrieved
    
    for proc in psutil.process_iter(['pid', 'name']):
        if proc.info['pid'] == active_pid:
            center_prog = re.search(pattern_middle, window_title)  # Extract middle part
            if center_prog:
                mid_info = center_prog.group(1)  # Extract the first group
            else:
                mid_info = window_title  # Fallback to full title
            
            last_part = re.search(pattern_program, mid_info)  # Extract program name
            if last_part:
                program = last_part.group(2)  # Extract program name
            else:
                program = mid_info  # Fallback
            
            return mid_info, program
    
    return None, None  # Return None if nothing found

# Dictionary to store tracking data
data_to_store = {}

# Tracking loop
run = True
sleeping_time = 10  # Time interval in seconds

while run:
    today_date = datetime.today().strftime('%d-%m-%Y')
    now = datetime.today().strftime('%H:%M')

    time.sleep(sleeping_time)

    project, program = active_win_open()
    if project is None or program is None:
        continue  # Skip if no valid window is found

    name = f"{program} - {project}"  # Correctly format the dictionary key

    if name in data_to_store:
        # If the program is already being tracked, update total time
        data_to_store[name]['total_time'] += sleeping_time
        data_to_store[name]['sessions'][-1]['end'] = now  # Update end time of last session
    else:
        # New program entry
        data_to_store.update({
            name: {
                'total_time': sleeping_time,
                'sessions': [{'start': now, 'end': now}],
                'date': today_date
            }
        })

# Debugging: Print stored data
print(data_to_store)
